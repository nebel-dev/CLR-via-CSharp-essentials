# CLR-via-CSharp-essentials
- [第1章 CLR的执行模型](#第1章-clr的执行模型)
  - [1.托管模块（中间语言、元数据、CLR头、PE头）](#1托管模块中间语言元数据clr头pe头)
  - [2.托管代码](#2托管代码)
  - [3.元数据](#3元数据)
  - [5.程序集](#5程序集)
  - [6.JIT编译器](#6jit编译器)
  - [7.JIT编译（运行时编译）](#7jit编译运行时编译)
  - [8.健壮性（鲁棒性）和可靠性](#8健壮性鲁棒性和可靠性)
  - [9.FCL](#9fcl)
  - [10.CTS](#10cts)
  - [11.CLS](#11cls)
- [第2章 生成、打包、部署和管理应用程序及类型](#第2章-生成打包部署和管理应用程序及类型)
- [第3章 共享程序集和强命名程序集](#第3章-共享程序集和强命名程序集)
- [第4章 类型基础](#第4章-类型基础)
  - [1.System.Object](#1systemobject)
  - [2.new](#2new)
  - [3.类型转换](#3类型转换)
  - [4.栈帧（StackFrame）](#4栈帧stackframe)
  - [5.类型对象](#5类型对象)
  - [6.类型对象指针](#6类型对象指针)
  - [7.同步块索引（<u>*待补充*</u>）](#7同步块索引u待补充u)
  - [8.调用非虚实例方法](#8调用非虚实例方法)
  - [9.调用虚实例方法](#9调用虚实例方法)
  - [10.调用静态方法](#10调用静态方法)
  - [11.线程栈](#11线程栈)
  - [12.GetType](#12gettype)
- [第5章 基元类型、引用类型和值类型](#第5章-基元类型引用类型和值类型)
  - [1.基元类型](#1基元类型)
  - [2.基元类型的使用建议](#2基元类型的使用建议)
  - [3.使用引用类型的需要注意](#3使用引用类型的需要注意)
  - [4.值类型](#4值类型)
  - [5.设计类型时的建议](#5设计类型时的建议)
  - [6.值类型的装箱和拆箱](#6值类型的装箱和拆箱)
  - [7. 值类型调用**<u>ToString</u>**方法会不会产生装箱？](#7-值类型调用utostringu方法会不会产生装箱)
  - [8.如何减少装箱](#8如何减少装箱)
  - [8.发生装箱的情况](#8发生装箱的情况)
  - [9.定义接口方法的必要性](#9定义接口方法的必要性)
  - [10.检查同一性](#10检查同一性)
  - [11.dynamic 和 var的区别](#11dynamic-和-var的区别)
- [第6章 类型和成员基础](#第6章-类型和成员基础)
  - [1.实例构造器、类型构造器](#1实例构造器类型构造器)
  - [2. c#关键字对组件版本控制的影响](#2-c关键字对组件版本控制的影响)
  - [3.分部类、结构和接口](#3分部类结构和接口)
- [第7章 常量和字段](#第7章-常量和字段)
  - [1.字段](#1字段)
- [第8章 方法](#第8章-方法)
  - [1.扩展方法](#1扩展方法)
  - [2.分部方法](#2分部方法)
- [第9章 参数](#第9章-参数)
  - [1.参数的默认值](#1参数的默认值)
  - [2.隐式类型的局部变量](#2隐式类型的局部变量)
  - [3.out 和 ref](#3out-和-ref)
  - [4.向方法传递可变数量的参数](#4向方法传递可变数量的参数)
  - [5.方法的参数类型](#5方法的参数类型)
  - [6.方法的返回类型](#6方法的返回类型)
- [第10章 属性](#第10章-属性)
  - [1.访问器（accessor）方法](#1访问器accessor方法)
  - [2.属性的可访问性](#2属性的可访问性)
  - [3.属性不能重载](#3属性不能重载)
  - [4.支持字段（backing field）](#4支持字段backing-field)
  - [5.自动实现的属性（AIP）](#5自动实现的属性aip)
  - [6.属性和字段的区别](#6属性和字段的区别)
  - [7.对象和集合初始化器](#7对象和集合初始化器)
  - [8.匿名类型](#8匿名类型)
  - [9.元组类型 System.Tuple](#9元组类型-systemtuple)
  - [10.有参属性  this [...]](#10有参属性--this-)
  - [11.属性访问器方法的性能](#11属性访问器方法的性能)
  - [12.属性访问器的可访问性](#12属性访问器的可访问性)
- [第11章 事件](#第11章-事件)
  - [1.事件成员](#1事件成员)
  - [2.事件如何使用](#2事件如何使用)
  - [3.设计要公开事件的类型](#3设计要公开事件的类型)
  - [4.事件的可访问性](#4事件的可访问性)
  - [5.设计侦听事件的类型](#5设计侦听事件的类型)
- [第12章 泛型](#第12章-泛型)
  - [1.泛型应用范围](#1泛型应用范围)
  - [2.开放类型和封闭类型](#2开放类型和封闭类型)
  - [3.泛型接口](#3泛型接口)
  - [4.泛型委托](#4泛型委托)
  - [5.泛型方法](#5泛型方法)
  - [6.可验证性和约束](#6可验证性和约束)
- [第13章 接口](#第13章-接口)
  - [1. 接口](#1-接口)
  - [2.接口的“继承”](#2接口的继承)
  - [3.xxx的类型与xxx的对象的类型](#3xxx的类型与xxx的对象的类型)
  - [4.泛型和接口约束](#4泛型和接口约束)
- [第14章 字符、字符串和文本处理](#第14章-字符字符串和文本处理)
  - [1.字符](#1字符)
  - [2.值类型与Char实例的相互转换](#2值类型与char实例的相互转换)
  - [3.String的 + 操作符](#3string的--操作符)
  - [4.字符串是不可变的](#4字符串是不可变的)
  - [5.高效执行大量字符串操作，建议使用StringBuilder类](#5高效执行大量字符串操作建议使用stringbuilder类)
  - [6.比较字符串  （P285）](#6比较字符串--p285)
  - [7. 字符串留用](#7-字符串留用)
  - [8.字符串池](#8字符串池)
  - [9.System.Globalization.StringInfo？](#9systemglobalizationstringinfo)
  - [10.System.Text.StringBuilder？](#10systemtextstringbuilder)
  - [11.StringBuilder与String的区别](#11stringbuilder与string的区别)
  - [12.将多个对象格式化成一个字符串](#12将多个对象格式化成一个字符串)
  - [13.解析字符串](#13解析字符串)
  - [14。编码：字符和字节的相互转换](#14编码字符和字节的相互转换)
  - [15.安全字符串](#15安全字符串)
- [第15章 枚举类型和位标志](#第15章-枚举类型和位标志)
  - [1.枚举类型](#1枚举类型)
  - [2.Isdefined](#2isdefined)
  - [3.位标志](#3位标志)
- [第16章 数组](#第16章-数组)
  - [1.数组](#1数组)
  - [2.初始化数组元素](#2初始化数组元素)
  - [3.数组转型](#3数组转型)
  - [4.数组元素的复制](#4数组元素的复制)
- [第17章 委托](#第17章-委托)
  - [1.委托的理解](#1委托的理解)
  - [2.委托的新增与移除](#2委托的新增与移除)
  - [3.委托中如何返回每个方法的结果？](#3委托中如何返回每个方法的结果)
  - [4.在一个类型中通过委托来调用另一个类型的私有成员，只要委托对象是由具有足够安全性/可访问性的代码创建的，便没有问题。](#4在一个类型中通过委托来调用另一个类型的私有成员只要委托对象是由具有足够安全性可访问性的代码创建的便没有问题)
  - [5.委托可以包装对实例方法和静态方法的调用](#5委托可以包装对实例方法和静态方法的调用)
  - [6.委托是类，可以定义类的地方都可以定义委托](#6委托是类可以定义类的地方都可以定义委托)
  - [7.委托类的构造器](#7委托类的构造器)
  - [8.Lambda表达式？](#8lambda表达式)
  - [9.泛型委托](#9泛型委托)
- [第18章 定制特性](#第18章-定制特性)
  - [1.自定义特性](#1自定义特性)
  - [2.定制特性的本质](#2定制特性的本质)
  - [3.特性类的实例构造器](#3特性类的实例构造器)
  - [4.可继承的目标元素](#4可继承的目标元素)
  - [5.自定义特性的应用](#5自定义特性的应用)
  - [6.检测定制特性](#6检测定制特性)
- [第19章 可空值类型](#第19章-可空值类型)
  - [1.System.Nullable\<T>结构](#1systemnullablet结构)
  - [2.C#对可空值类型的支持](#2c对可空值类型的支持)
  - [2.C#的空接合操作符 ??](#2c的空接合操作符-)
- [第20章 异常和状态管理](#第20章-异常和状态管理)
  - [1.try块](#1try块)
  - [2.catch块](#2catch块)
  - [3.finally块](#3finally块)
  - [4.StackTrace属性](#4stacktrace属性)
  - [5.定义自己的异常类](#5定义自己的异常类)
  - [6.捕捉异常](#6捕捉异常)
  - [7.throw关键字](#7throw关键字)
  - [8.异常处理的性能问题](#8异常处理的性能问题)
  - [9.约束执行区域（CER）](#9约束执行区域cer)
  - [10.代码协定（code contract）](#10代码协定code-contract)
- [第21章 托管堆和垃圾回收](#第21章-托管堆和垃圾回收)
  - [1.new操作符导致CLR执行以下步骤：](#1new操作符导致clr执行以下步骤)
  - [2.垃圾回收算法](#2垃圾回收算法)
  - [3.尽量避免使用静态字段](#3尽量避免使用静态字段)
  - [4.基于代的垃圾回收](#4基于代的垃圾回收)
  - [5.垃圾回收触发条件](#5垃圾回收触发条件)
  - [6.大对象](#6大对象)
  - [7.垃圾回收模式](#7垃圾回收模式)
  - [8.终结（finalization）](#8终结finalization)
  - [9.SafeHandle类 ？](#9safehandle类-)
  - [10.IDisposable接口 ?](#10idisposable接口-)
  - [11.终结的内部工作原理](#11终结的内部工作原理)
- [第22章 CLR寄宿和AppDomain](#第22章-clr寄宿和appdomain)
  - [1.](#1)
# 第1章 CLR的执行模型

## 1.托管模块（中间语言、元数据、CLR头、PE头）

托管模块是标准32位Microsoft Windows可移植执行体（PE32）文件，或64位（PE32+）文件，需要**CLR**执行。

## 2.托管代码

IL（中间语言）代码

## 3.元数据

数据表集合，描述IL代码，两者同时生成，永远保持同步。

由三种表构成的二进制数据块，定义表、引用表、清单表。

## 5.程序集

由C#编译器将托管模块和资源文件合并而成。与非托管组件相比，程序集更容易部署。

CLR操作的是程序集，程序集可以是可执行应用程序，也可以是DLL，最终由CLR管理执行。

程序集是进行重用、版本控制和应用安全性设置的基本单元。

名为清单的数据块描述程序集中的文件集，使程序集有了自描述性。

## 6.JIT编译器

代码中的方法有对应的记录项（entry），记录项含有一个地址。CLR分配一个内部结构，将每个记录项都设置成（指向）包含在CLR内部的一个未编档函数，将之称为JITCompiler。

## 7.JIT编译（运行时编译）

方法调用的同时，对应的JITCompiler会被调用，JITCompiler将方法的IL代码编译成本机CPU指令。【IL是“即时”编译的】

*详细过程：JITCompiler知道是什么类型定义了该方法，它在定义（该类型）的程序集的元数据中查找被调用方法的IL→JITCompiler验证IL代码，并将其编译成本机CPU指令，保存在动态分配的内存块中→返回CLR为类型创建的内部数据结构，找到对应的记录项，修改初始化时对JITCompiler的引用，指向刚才内存块的地址→JITCompiler函数跳转到内存块代码。*

【应用程序终止，编译好的代码被丢弃，下次运行需要再次编译】

## 8.健壮性（鲁棒性）和可靠性

前者：系统对于参数变化的不敏感性

后者：系统的正确性

## 9.FCL

Framework Class Library，Framework类库，一组DLL程序集的统称，数千个类型定义，以命名空间分类，例如System命名空间包含Object基类型等。

## 10.CTS

Common Type System，通用类型系统，正式的规范来描述类型的定义和行为，CTS规定一个类型可以包含零个或多个成员（字段、方法、属性、事件）

CTS指定了类型可见性规则和成员访问规则：

- private
- family (protected)
- family and assembly (c#不提供)
- assembly (internal)
- family or assembly (c#用 protected internal)
- public

CTS规定所有类型从System.Object类型继承。（允许equals，get hash，get type，浅拷贝，to string）

## 11.CLS

Common Language Specification，公共语言规范。CLR中不同语言中其他所有语言都支持的功能，是一个最小功能集。

# 第2章 生成、打包、部署和管理应用程序及类型

# 第3章 共享程序集和强命名程序集

# 第4章 类型基础

## 1.System.Object

公共方法：

- ToString：默认返回类型的完整名称（this.GetType().FullName）
- Equals
- GetHashCode
- Get Type：非虚方法，目的是防止类重写该方法，隐瞒其类型，进而破坏类型安全性。

## 2.new

1. 计算类型中定义的所有实例字段需要的字节数，包含类型对象指针、同步块索引；
2. 从托管堆分配内存，分配的所有字节设为0；
3. 初始化类型对象指针、同步块索引；
   - 类型对象指针被初始化为对System.Type类型对象的引用；
   - 同步块索引被初始化为-1.
4. 调用类型的实例构造器。

## 3.类型转换

1. 可直接将对象转换为它的任何基类型（安全）；

2. 将对象转换为它的派生类型**必须**显式转换；

   显式类型转换有可能在**运行时失败**：System.InvalidCastException

3. 使用**is**和**as**操作符来转型：

   - is检查对象是否**兼容**于指定类型，永不抛出异常；
   - as与强制类型转换一样，如果不能转型，结果为null，如果可以则返回对同一个对象的非null引用；

4. 不安全转换表示可能丢失精度或数量级，此时要求显式转型。

## 4.栈帧（StackFrame）

代表当前线程的调用栈中的一个方法调用。执行线程的过程中，进行的每个方法调用都会在调用栈中创建并压入一个StackFrame。

## 5.类型对象

类型的元数据就是所谓的“类型对象”。

<!--就是类吧？-->对象对应的是类型对象，对象是类型对象的实例。

类型内静态数据字段需要的字节在类型对象自身中分配；

每个类型对象包含**静态字段**和一个**方法表**，表中包含所定义方法的记录项（entry）；

## 6.类型对象指针

在堆上新建对象，CLR都自动初始化内部的“类型对象指针”成员来引用和对象对应的类型对象。

<!--类型对象的类型对象指针指向System.Type-->

## 7.同步块索引（<u>*待补充*</u>）

.NET框架只为每个堆内对象分配一个同步索引，该索引中只保存一个表明数组内索引的整数。.NET在加载时会新建一个同步块数组，当某个对象需要被同步时，.NET会为其分配一个同步块，并且把该同步块在同步块数组中的索引加入该对象的同步块索引中。

同步块机制包含如下的几点：

- 在.NET被加载时初始化同步块数组。
- 每一个被分配在堆上的对象都会包含两个额外的字段，其中一个存储类型指针，而另外一个就是同步块索引，初始时被赋值为-1。
- 当一个线程试图使用该对象进入同步时，会检查该对象的同步索引。如果索引为负数，则会在同步块数组中寻找或者新建一个同步块，并且把同步块的索引值写入该对象的同步索引中。如果该对象的同步索引不为负值，则找到该对象的同步块并且检查是否有其他线程在使用该同步块，如果有则进入等待状态，如果没有则申明使用该同步块。

**同步块是指.NET维护的同步块数组中的某个元素**，初始被赋值为-1。

<!--待补充-->

## 8.调用非虚实例方法

JIT编译器会找到与“发出调用的那个变量的类型”对应的类型对象，如果此类型没有定义正在调用的方法，JIT编译器会回溯类层次结构（一直到Object，在沿途的每个类型中查找该方法）。

可以回溯的原因：每个类型对象都有一个字段引用了它的基类型。

## 9.调用虚实例方法

此时，JIT编译器要在方法中生成一些额外的代码，方法每次调用都要使用这些代码。这些代码首先检查**发出调用的变量**，跟随地址来到**发出调用的对象**（*<u>发出调用的变量的类型与发出调用的对象的类型不一定相同</u>*）。然后，代码在类型对象的方法表中查找引用了被调用方法的记录项，对其进行JIT编译，再调用JIT编译好的代码。

## 10.调用静态方法

CLR会定位与定义静态方法的类型对应的类型对象，然后JIT编译器在类型对象的方法表中查找与被调用方法对应的记录项，对方法JIT编译，再调用JIT编译好的代码。

## 11.线程栈

栈空间用于向传递方法的实参，方法内部定义的局部变量也在栈上。

<!--栈帧展开（unwind）-->

## 12.GetType

方法返回存储在指定对象的“类型对象指针”成员中的地址，即返回指向对象的类型对象的指针。

# 第5章 基元类型、引用类型和值类型

## 1.基元类型

编译器直接支持的数据类型，基元类型直接**映射到FCL中存在的类型**。

***建议使用FCL类型名称***

![](C:\Users\yangxinsheng\Desktop\微信截图_20190729201457.png)

## 2.基元类型的使用建议

- 尽量使用有符号数值类型（Int32、Int64）；
- 如果不希望发生溢出，就把代码放到checked块中，同时捕捉OverflowException；
- 将允许发生溢出的代码**显式**放到unchecked块中，比如计算校验和时；
- 对于没有使用checked或unchecked的任何代码，都假定你希望在发生溢出时抛出异常，此时的溢出应被**记为bug**。

## 3.使用引用类型的需要注意

- 内存从堆上分配
- 每个对象有额外成员，且必须初始化
- 对象中其他字节（为字段而设）总是设为零
- 从托管堆分配对象时，可能强制执行一次垃圾回收。

## 4.值类型

值类型实例在线程栈上分配，变量已包含实例的字段，所以操作实例中的字段不需要提领指针。

值类型：结构或枚举，所有结构都是抽象类型**System.ValueType**的直接派生类，**System.ValueType**从**System.Object**派生。所有枚举都从**System.Enum**抽象类型派生，**System.Enum**又从**System.ValueType**派生。

值类型有两种状态：**已装箱**和**未装箱**，引用类型总是已装箱。

## 5.设计类型时的建议

除非满足一下全部条件，否则不应将类型声明为值类型。

- 类型具有基元类型的行为（没有成员会修改类型的任何实例字段）
- 类型不需要从其他任何类型继承
- 类型不派生出其他任何类型

此外，要将类型声明为值类型还需满足以下任意条件：

- 类型的实例较小（16字节或更小）
- 类型的实例较大，但不作为方法实参传递，也不从方法返回

定义自己的值类型时应重写：**Equals**和**GetHashCode**方法，并提供显式实现。

不应在值类型中引入任何新的虚方法，因为值类型不能作为基类。所有方法都隐式密封不可重写。

## 6.值类型的装箱和拆箱

装箱的原因：需要获取对值类型实例的引用。

**装箱**的过程：

1. 在托管堆中分配内存，分配的内存量时值类型各字段所需的内存量加上托管堆所有对象都有的两个额外成员（类型对象指针和同步块索引）所需的内存量；
2. 值类型的字段复制到新分配的堆内存；
3. 返回对象地址。现在该地址是对象引用；值类型成了引用类型。

**拆箱**的过程：已装箱对象中的所有字段都必须复制到值类型变量中，后者在线程栈上。

1. 获取已装箱对象中的各个字段的地址，这一过程称为拆箱；
2. 将字段包含的值复制到基于栈的值类型实例中。

拆箱就是获取指针的过程，该指针指向的是已装箱实例中的未装箱部分，即指向包含在一个对象中的原始值类型（数据字段）。

<u>注：拆箱时，只能转型为最初未装箱的值类型，不能强制转型</u>

<u>注：一个变量装箱前和拆箱后在内存中的地址**不改变**</u>

## 7. 值类型调用**<u>ToString</u>**方法会不会产生装箱？

[ValueType.ToString]: https://docs.microsoft.com/zh-cn/dotnet/api/system.valuetype.tostring?view=netframework-4.8#System_ValueType_ToString

## 8.如何减少装箱

- 定义自己的类时，可将类中的方法定义为泛型（通过类型约束将类型参数限制为值类型）。这样方法就可获取任何值类型不必装箱。
- 如果一个值类型被反复装箱，请用手动方式对值类型进行装箱。

## 8.发生装箱的情况

- 调用值类型重写的**虚方法**，如果重写的虚方法要调用方法在基类中的实现，发生装箱，以便能够通过this指针将一个堆对象的引用传给基方法。
- 调用**非虚的、继承的方法**时，发生装箱，因为这些方法由**System.Object**定义，要求this实参是指向堆对象的指针。
- 将值类型的未装箱实例转型为类型的某个**接口**时，发生装箱，因为接口变量必须包含对堆对象的引用。（接口是引用类型）
- **ToString**方法在内部调用**base.ToString()**，那么在调用**System.ValueType**的**ToString**方法时，发生装箱。

## 9.定义接口方法的必要性

- 必须使用接口方法，才能修改已装箱的值类型中的字段。

## 10.检查同一性

看两个引用是否指向同一个对象，必须调用**ReferenceEquals**，不应使用**==**操作符，因为**==**有可能被重载。

## 11.dynamic 和 var的区别

- **var**只能在方法内部声明局部变量，**dynamic**可用于局部变量、字段和参数；
- 表达式不能转型为**var**，但能转型为**dynamic**；
- 必须显式初始化用**var**声明的变量，无需初始化用**dynamic**声明的变量。

# 第6章 类型和成员基础

## 1.实例构造器、类型构造器

实例构造器是将新**对象**的实例字段初始化的方法；类型构造器是将**类型**的静态字段初始化的方法。

## 2. c#关键字对组件版本控制的影响

![1564456799379](C:\Users\yangxinsheng\AppData\Roaming\Typora\typora-user-images\1564456799379.png)

## 3.分部类、结构和接口

# 第7章 常量和字段

## 1.字段

字段的数据在动态内存中存储，所以它们的值在运行时才能获取。

# 第8章 方法

## 1.扩展方法

第一个参数前面有this的方法。也只有第一个参数能用this关键字标记。

必须在非泛型的静态类中声明，且该静态类不能是嵌套类，必须是**顶级静态类**。

注意：扩展方法扩展了一个类型时，同时扩展了派生类型。

扩展方法**实际是对一个静态方法的调用**，所以CLR不会生成代码对调用方法的表达式的值进行null值检查。

## 2.分部方法

# 第9章 参数

## 1.参数的默认值

- 有默认值的参数必须放在没有默认值的所有参数之后
- 默认值必须是编译时能确定的常量值，可用**default**或**new**关键字来表达这个意思。
- **ref**或**out**标识的参数不能设置默认值

## 2.隐式类型的局部变量

**var**关键字能用于foreach、using、for；

不能用**var**声明类型中的字段，<u>匿名类型会泄露到方法外部（第10章）</u>；

不能用**var**声明方法的参数类型，根据传递的实参推断类型会出错。

## 3.out 和 ref

从IL和CLR角度看，不区分两者；C#编译器区分，编译器会按照不同的标准验证你的代码的正确性。

**out：**方法参数用**out**标记，表明不指望调用者在调用方法之前初始化好了对象。

**ref：**方法参数用**ref**标记，表明调用者必须在调用该方法前初始化参数的值。

为大的值类型使用**out**，可提高效率，避免了方法调用时复制值类型实例的字段。

## 4.向方法传递可变数量的参数

**params**关键字，只能应用于方法签名中的最后一个参数。

**params**关键字告诉编译器向参数应用定制特性**System.ParamArrayAttribute**的一个实例。

注：参数数量可变的方法对性能有影响，因为数组对象必须在堆上分配，数组元素必须初始化。可定义几个没有**params**关键字的重载版本应用于常规情形。

## 5.方法的参数类型

声明方法的参数类型，应尽量指定**最弱**的类型，宁要接口不要基类，这样更灵活，适合更广泛的情形。

## 6.方法的返回类型

最好将方法的返回类型声明为**最强**的类型

# 第10章 属性

## 1.访问器（accessor）方法

封装了字段访问的方法

## 2.属性的可访问性

属性可用任意“可访问性”修饰符来标记

## 3.属性不能重载

不能定义名称相同、类型不同的两个属性；

可省略**set**方法来定义只读属性，省略**get**方法来定义只写属性；

## 4.支持字段（backing field）

私有字段

## 5.自动实现的属性（AIP）

使用AIP，属性必然是可读可写的。

## 6.属性和字段的区别

- 属性可以只读或只写，字段总是可读可写；
- 属性不能作为**out**或**ref**参数传给方法，字段可以；
- 属性方法执行时间长，字段访问立即完成；要线程同步就不要使用属性，要使用方法。
- 多次调用，属性可能会返回不同的值，字段访问永远不会；
- 属性方法可能产生副作用，字段访问永远不会
- <u>属性会返回一个拷贝，容易引起混淆</u>**？**

## 7.对象和集合初始化器

如果属性的类型实现了IEnumerable或IEnumerable<T>接口，属性被认为是集合，集合的初始化是相加的操作，而非替换操作。

## 8.匿名类型

```c#
var o1 = new { Name = "Jeff", Year = 1933 };
```


编译器自动创建类型名称，且不会告诉我。但可以使用“隐式类型局部变量”功能（**var**），它的作用是告诉编译器赋值操作符**（=）**右侧的表达式推断类型。

只创建私有字段，为每个字段创建公共只读属性

## 9.元组类型 System.Tuple

**tuple**来源于对顺序的抽象：single、double、triple、quadruple、quintuple、n-tuple。

和匿名类型相似，**Tuple**创建好之后就不可变了（所有属性都只读）

## 10.有参属性  this [...]

有参属性的**get**访问器接受一个或多个参数，**set**访问器方法接受两个或多个参数。

C#中称其为**索引器**；可将其看成是对 **[ ]** 操作符的重载；

- 可以通过查看类型是否提供了名为Item的属性，从而判断是否提供了索引器。
- c#只允许在对象的实例上定义索引器，不支持定义静态索引器属性。
- c#允许一个类型定义多个索引器

## 11.属性访问器方法的性能

一般JIT编译器会将get、set方法的代码内联，使生成的本机代码更小，执行更快。

注：JIT编译器在调试代码时不会内联属性方法。

## 12.属性访问器的可访问性

成员前的访问修饰符对访问器方法的可访问性的影响？

```c#
private string name = "Hello";
public string Name
{
    get
    {
        return name;
    }
    //Using "protected" would make the set accessor not accessible. 
    //Using private on the following property hides it in the Main Class.
    //Any assignment to the property will use accessor in BaseClass.
    protected set
    {
        name = value;
    }
}
```

默认情况下，这些访问器具有与其所属属性或索引器相同的可见性或访问级别。 **与成员前的访问修饰符没有关系。**通常是在保持 `get` 访问器可公开访问的情况下，限制 `set` 访问器的可访问性。

- 仅当同时具有get、set访问器时，才能使用访问器修饰符，且只允许对其中一个访问器使用修饰符。
- 访问器的可访问性级别必须比属性或索引器本身的可访问性级别具有更严格的限制。
- 不能对接口或显式[接口](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface)成员实现使用访问器修饰符。
- 如果属性或索引器具有 [override](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/override) 修饰符，则访问器修饰符必须与重写的访问器的访问器（如有）匹配。

# 第11章 事件

## 1.事件成员

类型能提供事件通知功能，是因为类型维护了一个已登记方法的列表，事件发生后，类型将通知列表中所有已登记的方法。

对象凭借回调方法接受它们订阅的通知。

## 2.事件如何使用

1. 构造类型的一个实例，该类型提供了一个事件；
2. 构造其他对象时，可以向该类型的事件登记自己的一个实例方法；
3. 事件触发时，所有已登记的方法都有机会以自己的方式处理该事件。

## 3.设计要公开事件的类型

**步骤**

1. 定义类型来容纳所有需要发送给事件通知接收者的附加信息；
2. 定义事件成员；
3. 定义负责引发事件的方法来通知事件的登记对象，一个受保护的虚方法（如果类是密封的，该方法要声明为私有和非虚）；
4. 定义方法将输入转化为期望事件。

## 4.事件的可访问性

一般为**public**，当事件声明为**protected**时，编译器生成的**add**和**remove**方法也会被声明为**protected**。

## 5.设计侦听事件的类型

定义一个类型来使用另一个类型提供的事件。

# 第12章 泛型

## 1.泛型应用范围

泛型引用类型、泛型值类型、泛型接口、泛型委托

泛型算法有更佳的性能，值类型的实例能以**传值**方式传递，CLR不再需要执行装箱操作。

泛型最明显的应用就是**集合类**。**System.Array**类（所有数组类型的基类）提供了大量静态泛型方法。

## 2.开放类型和封闭类型

**开放类型**是具有泛型类型参数的类型，不能构造开放类型的实例；

为所有类型参数都传递了实际的数据类型，类型就成为**封闭类型**；每个封闭类型都有自己的静态字段。

## 3.泛型接口

非泛型接口操纵值类型都会发生装箱，且会失去编译时的类型安全性。

## 4.泛型委托

作用是保证任何类型的对象都能以类型安全的方式传给回调方法。此外，泛型委托允许值类型实例在传给回调方法时**不进行任何装箱**。

- 委托的每个泛型类型参数都可标记为协变量（out）或逆变量（in)；
- 逆变量：泛型类型参数可从一个类更改为它的某个派生类；
- 协变量：泛型类型参数可从一个类更改为它的某个基类；

## 5.泛型方法

## 6.可验证性和约束

# 第13章 接口

## 1. 接口

接口只是对一组方法签名进行了统一命名，方法不提供任何实现。

在CLR看来，接口定义就是类型定义

## 2.接口的“继承”

不完全和类继承一样，可将接口继承看成是将其他接口的协定(contract)包括到新接口中。

## 3.xxx的类型与xxx的对象的类型

## 4.泛型和接口约束

可将泛型类型参数约束为接口，有以下好处：

- 传递的参数的类型必须实现全部接口约束
- 传递值类型实例时减少装箱

# 第14章 字符、字符串和文本处理

## 1.字符

字符是16位Unicode代码值，每个字符都是System.Char结构的实例。

## 2.值类型与Char实例的相互转换

三种实现技术：

- 转型（强制类型转换），效率最高；
- 使用Convert类型，以checked方式执行，转换过程丢失数据抛出OverflowException异常
- 使用IConvertible接口，效率最低。

## 3.String的 + 操作符

当所有字符串都是字面值时，C#编译器在编译时连接它们；对非字面值字符串使用+操作符，连接则在运行时进行。

因此，运行时连接不要使用+操作符，因为这样会在堆上创建多个字符串对象，需要垃圾回收，对性能有影响，应使用**System.Text.StringBuilder**类型。

## 4.字符串是不可变的

意味着操纵或访问字符串时不会发生线程同步问题。

## 5.高效执行大量字符串操作，建议使用StringBuilder类

## 6.比较字符串  （P285）

## 7. 字符串留用

如果经常对字符串进行区分大小写的序号比较，或者事先知道许多字符串对象都有相同的值，就可利用CLR的**字符串留用**提升性能。

CLR初始化时会创建一个内部哈希表，键(key)是字符串，值(value)是对托管堆中的**String**对象的引用。

<u>注：垃圾回收器不能释放内部哈希表引用的字符串，因为哈希表正在容纳对它们的引用，除非卸载AppDomain或进程终止。</u>

## 8.字符串池

编译器将单个字符串的多个实例合并成一个实例。

## 9.System.Globalization.StringInfo？

检查字符串中的字符和文本元素

## 10.System.Text.StringBuilder？

可将**StringBuilder**看成创建**String**对象的特殊构造器。**StringBuilder**对象包含一个字段，该字段引用了由Char结构构成的数组。如果字符串变大，**StringBuilder**会自动分配一个新的更大的数组（倍增），复制字符，开始使用新数组，旧数组被垃圾回收。

## 11.StringBuilder与String的区别

StringBuilder代表可变字符串，StringBuilder的大多数成员都能更改字符数组的内容，同时不会在托管堆上分配新对象。

StringBuilder在以下两种情况会在堆上分配新对象：

- 动态构造字符串，长度超过设置的容量；
- 调用StringBuilder的ToString方法。

## 12.将多个对象格式化成一个字符串

**String.Format**，静态方法，内部，Format方法会调用每个对象的ToString方法来获取对象的字符串表示。

## 13.解析字符串

公共静态方法Parse，方法获取一个String并返回类型的实例。

## 14。编码：字符和字节的相互转换

不显式指定编码方案，默认使用UTF-8.

- UTF-16将每个16位字符编码成2个字节，不发生压缩——性能非常出色；
- UTF-8将部分字符编码成1个字节，部分编码成2个、3个、4个字节。效率不如UTF-16.

## 15.安全字符串

System.Security.SecureString，在构造SecureString对象时，会在内部分配一个非托管内存块，其中包含一个字符数组，使用非托管内存是为了避开垃圾回收器。

# 第15章 枚举类型和位标志

## 1.枚举类型

是一个结构，其中定义了**一组常量字段和一个实例字段**。常量字段会嵌入程序集的元数据中，并可通过反射来访问。

每个枚举类型都有一个基础类型，不能用FCL类型，只能指定基元类型名称：**byte**、**sbyte**、**short**、**ushort**、**int**（默认）、**uint**、**long**、**ulong**。

注：C#将枚举类型视为基元类型，所以可用许多操作符（==、！=、<、>、<=、>=、+、-、^、&、|、~、++、--），这些操作符实际作用于每个枚举类型实例内部的**value_**实例字段。

## 2.Isdefined

可用**Isdefined**方法判断数值对于某枚举类型是否合法。经常被用于**参数校验**。

## 3.位标志

经常要用枚举类型来表示一组可以组合的位标志。但是，枚举类型表示单个数值，位标志表示位集合，其中一些位处于on状态，一些处于off状态。

注：永远不要对位标志枚举类型使用**Isdefined**，原因：

- 它不会将字符串拆分为单独的token来进行查找；
- 针对传递的数值，它会检查枚举类型是否定义了其数值和传入数值匹配的一个符号。但**bit flag**一般都要组合起来使用，不能这样简单匹配，所以**Isdefined**通常会返回**false**。

# 第16章 数组

## 1.数组

所有数组隐式从System.Array抽象类派生，后者派生自System.Object，所以数组始终是引用类型，在托管堆上分配。

## 2.初始化数组元素

方法1：

```c#
//大括号中的每个数据项称为数组初始化器，每个数据项都可以是一个任意复杂度的表达式；多维数组中可嵌套。
String[] names=new String[]{"Aiden","Grant"};
```

方法2：

```c#
//利用C#隐式类型局部变量功能
var names=new String[] {"Aiden"，"Grant"};
var names=new[] {"Aiden"，"Grant",null};//null可隐式转型位任意引用类型
```

方法3：

```c#
//赋值操作符=右边只给出一个初始化器，没有new，没有类型，没有[]
String[] names={"Aiden"，"Grant"};
```

## 3.数组转型

**Array.Copy**，方法执行的是浅拷贝，即如果数组元素是引用类型，新数组将引用现有的对象。

- 元素为引用类型，CLR允许转型，要求数组维数相同；

- 元素为值类型，CLR不允许转型；

## 4.数组元素的复制

- 如果只是需要将数组的某些元素复制到另一个数组，可用System.Buffer的BlockCopy方法，比Array的Copy快。
- 要将一个数组的元素可靠地复制到另一个数组，应使用System.Array的ConstrainedCopy方法。它不执行任何装箱、拆箱或向下类型转换。

# 第17章 委托

## 1.委托的理解

**委托是用户自定义的类，它定义了方法的类型。**储存的是一系列具有相同参数和返回类型方法的地址列表，调用委托时，此委托列表的所有方法都将被执行。（委托就是可以用方法名调用另一方法的便捷方法）

```c#
namespace Func
{
    public delegate int MyDel(int num);//声明一个自定义委托
    class Program
    {
        static int Add1(int a)
        {
            int b = 10 + a;
            Console.WriteLine("——Add1———");
            return b;
 
        }
 
        static int Add2(int a)
        {
            int b = 10 - a;
            Console.WriteLine("——Add2———");
            return b;
 
        }
 
        static void Calculate(MyDel ex, int a)
        {
            var result = ex(a);
            Console.WriteLine(result + "\n");
        }
 
        static void Main(string[] args)
        {
            Calculate(Add1, 1);
            Calculate(Add2, 10);
            Console.ReadKey();
        }
    }
}
```

![img](https://img-blog.csdn.net/20180512235217352)

## 2.委托的新增与移除

可以使用+=运算符，为委托新增方法。

同样可以使用-=运算符，为委托移除方法。

**当委托列表中有几个方法时，调用委托时，则会依次经过各个方法，并返回列表最后一项方法的结果**

```c#
namespace Func
{
    public delegate int MyDel(int num);//声明一个自定义委托
    class Program
    {
 
        static int Add1(int a)
        {
            int b = 10 + a;
            Console.WriteLine("——Add1———");
            return b;
 
        }
 
        static int Add2(int a)
        {
            int b = 10 - a;
            Console.WriteLine("——Add2———");
            return b;
 
        }
 
        static void Calculate(MyDel ex, int a)
        {
            var result = ex(a);
            Console.WriteLine(result + "\n");
        }
 
        static void Main(string[] args)
        {
            //Calculate(Add1, 1);
            //Calculate(Add2, 10);
            MyDel myDel = Add1;
            myDel += Add2;
            Calculate(myDel, 10);
            Console.ReadKey();
        }
    }
}
```

![img](https://img-blog.csdn.net/20180513000224634)

## 3.委托中如何返回每个方法的结果？

## 4.在一个类型中通过委托来调用另一个类型的私有成员，只要委托对象是由具有足够安全性/可访问性的代码创建的，便没有问题。

## 5.委托可以包装对实例方法和静态方法的调用

包装实例方法很有用，因为对象内部的代码可以访问对象的实例成员。这样对象可以维护一些状态，并在回调方法执行期间利用这些状态信息。

## 6.委托是类，可以定义类的地方都可以定义委托

## 7.委托类的构造器

它获取两个参数：一个是对象引用，另一个是引用了回调方法的整数。

```c#
//构造器
public Feedback(Object @object, IntPtr method);
```

C#编译器会分析源代码来确定引用的是哪个对象和方法。对于静态方法，object参数传递null

## 8.Lambda表达式？

## 9.泛型委托

- **Action**委托，0-16个参数
- **Func**委托，允许回调方法返回值

需要定义自己的委托

- 如果使用**ref**或**out**关键字以传引用的方式传递参数
- 通过C#的**params**关键字获取数量可变的参数
- 对委托的泛型类型参数进行约束

# 第18章 定制特性

## 1.自定义特性

它们只是将一些附加信息与某个目标元素关联起来的方式。面向CLR的编译器都要识别定制特性，并在最终的元数据中生成特性信息。

FCL定义了几百个定制特性，例如：

- **DllImport**特性应用于方法，告诉CLR该方法的实现位于指定DLL的非托管代码中；
- **Serializable**特性应用于类型，告诉序列化格式化器一个实例的字段可以序列化和反序列化；
- **Flags**特性应用于枚举类型，枚举类型就成了位标志（bit flag）集合。

**注：**

- CLR允许将特性应用于可在文件的元数据中表示的几乎任何东西。具体说，C#只允许将特性应用于定义以下目标元素的源代码：程序集、模块、类型（类、结构、枚举、接口、委托）、字段、方法（含构造器）、方法参数、方法返回值、属性、事件和泛型类型参数。
- 应用于程序集、模块、返回值的特性，需要用一个前缀明确指定特性要应用于的目标元素。

## 2.定制特性的本质

本质是一个类型的实例。定制特性类必须直接或间接从公共抽象类**System.Attribute**派生。

## 3.特性类的实例构造器

- 将特性应用与目标元素时，调用类的**实例**构造器。
- 构造器的参数称为定位参数，**必须指定**。
- 用于设置字段或属性的参数称为**命名参数**，可选。

## 4.可继承的目标元素

.NET Framework只认为类、方法、属性、事件、字段、方法返回值、参数等元素可继承。此时**AttributeUsage**特性可将**Inherited**设为**true**。

## 5.自定义特性的应用

[自定义特性实战]: https://www.cnblogs.com/zhengwei-cq/p/8469285.html

内部过程：

- 编译器构造并初始化好定制特性类的对象后，编译器将它的状态序列化到目标元素的元数据表记录项中。

## 6.检测定制特性

**System.Reflection.CustomAttributeExtensions**类定义了三个静态方法来获取与目标关联的特性：**IsDefined**, **GetCustomAttributes**, **GetCustomAttribute**.

# 第19章 可空值类型

## 1.System.Nullable\<T>结构

![1564580826882](C:\Users\yangxinsheng\AppData\Roaming\Typora\typora-user-images\1564580826882.png)

输出：

![1564580847832](C:\Users\yangxinsheng\AppData\Roaming\Typora\typora-user-images\1564580847832.png)

## 2.C#对可空值类型的支持

![1564581010408](C:\Users\yangxinsheng\AppData\Roaming\Typora\typora-user-images\1564581010408.png)

C#允许在可空实例上执行转换和转型，还可向可空实例应用操作符。

## 2.C#的空接合操作符 ??

**??**操作符要获取两个操作数，如果左边的操作数不为**null**，就返回这个操作数的值。如果左边的操作数为**null**，就返回右边的操作数的值。

注：既能用于引用类型，也能用于可空值类型

![1564581468737](C:\Users\yangxinsheng\AppData\Roaming\Typora\typora-user-images\1564581468737.png)

# 第20章 异常和状态管理

## 1.try块

一个**try**块至少要有一个关联的**catch**块或**finally**块。

## 2.catch块

**catch**包含的是响应一个异常需要执行的代码。如果没有抛出异常，线程直接执行**finally**块。**catch**关键字后圆括号中的表达式称为捕捉类型。必须是System.Exception或他的派生类型。

CLR自上而下搜索匹配**catch**块，所以应将具体的异常放在顶部。

如果没有任何捕捉类型与抛出的异常匹配，CLR会去调用栈更高的一层(?)搜索与异常匹配的捕捉类型。如果到了调用栈的顶部还没有找到匹配的**catch**块，就发生未处理的异常。

一旦CLR找到匹配的**catch**块，就会执行内层所有**finally**块中的代码，然后执行匹配异常的**catch**块中的代码，在**catch**块末尾，有三个选择：

- 重新抛出相同的异常，向调用栈高一层的代码通知该异常的发生；
- 抛出一个不同的异常，向调用栈高一层的代码提供更丰富的异常信息；
- 让线程从**catch**块底部退出。（正常执行**catch**块，并执行匹配的**finally**块）

## 3.finally块

**finally**块包含的是保证会执行的代码。一般在**finally**块中执行**try**块的行动所要求的资源清理操作，例如关闭文件。

如果**catch**或**finally**块内部抛出异常，CLR不会记录对应的try块中抛出的第一个异常，关于第一个异常的所有信息（例如堆栈跟踪）都将丢失。新异常通常会变成一个**未处理异常**，导致CLR**终止进程**。

## 4.StackTrace属性

System.Exception的StackTrace属性，catch块可读取该属性来获取堆栈跟踪。

CLR只记录最新的异常对象的抛出位置。

## 5.定义自己的异常类

需要从**Exception**类派生，且都应该是可序列化的（serializable）。

## 6.捕捉异常

不要写“大小通吃”的类型，悄悄“吞噬”异常，而是应该允许异常在调用栈中向上移动，让应用程序代码针对性地处理它。

## 7.throw关键字

重新抛出相同的异常，只需单独使用C#的**throw**关键字，不在**throw**后指定任何东西。

## 8.异常处理的性能问题

## 9.约束执行区域（CER）

## 10.代码协定（code contract）

# 第21章 托管堆和垃圾回收

## 1.new操作符导致CLR执行以下步骤：

1. 计算类型字节数
2. 加上对象的开销所需的字节数
3. CLR检查区域中是否有分配对象所需的字节数。

利用**NextObjPtr**指针指向下一个对象在堆中的分配位置。

## 2.垃圾回收算法

堆上每个对象都维护着一个**内存字段**来统计程序中多少“部分”正在使用对象。计数字段变成0，对象就可以从内存中删除了。

CLR使用**引用跟踪算法**，算法只关心引用类型的变量，因为只有这种变量才能引用堆上的对象；将所有引用类型变量称为**根**。

GC过程：

1. 暂停进程中所有线程
2. 遍历堆中所有对象，将同步索引字段中的一位设为0；表明都要删除
3. 检查所有活动根，查看它们引用了哪些对象，如果一个根包含null，忽略这个根检查下一个
4. 如果根引用了堆上对象，CLR将该对象同步块索引中的位设为1，然后CLR检查该对象中的根，标记它们引用的对象，如果发现对象已经标记，就不重新检查对象的字段。这避免了因为循环引用产生的死循环。
5. 检查完毕，已标记的对象不被垃圾回收，之后进行GC的压缩阶段，使剩余的对象占用连续的内存空间。
6. 最后，CLR要从每个根减去所引用对象在内存中偏移的字节数。
7. 压缩阶段完成后，CLR恢复所有线程。

## 3.尽量避免使用静态字段

静态字段引用的对象一直存在，直到用于加载类型的AppDomain卸载，静态字段引用某个集合对象可能会导致内存泄漏。

## 4.基于代的垃圾回收

托管堆只支持三代：0，1，2

## 5.垃圾回收触发条件

- 显式调用System.GC
- Windows报告低内存情况
- CLR正在卸载AppDomain
- CLR正在关闭

## 6.大对象

85000字节或更大的对象，总是第2代.GC不压缩大对象。

## 7.垃圾回收模式

- 工作站（默认）
- 服务器

子模式：并发、非并发

## 8.终结（finalization）

CLR判定一个对象不可达时，对象将终结它自己，释放它包装的本机资源，之后GC会从托管堆回收对象。

注：被视为垃圾的对象在垃圾回收完毕后才调用Finalize方法，内存不是马上回收，因为Finalize方法要访问字段。这造成它被提升至下一代，使对象活得比正常时间长，增大了内存耗用，尽量避免为引用类型的字段定义可终结对象。

## 9.SafeHandle类 ？

## 10.IDisposable接口 ?

## 11.终结的内部工作原理

终结列表：如果对象的类型定义了Finalize方法，在该类型的实例构造器被调用之前，会将指向该对象的指针放到一个终结列表中。由垃圾回收器控制。

垃圾回收开始后，垃圾回收器扫描终结列表查找对这些对象的引用，将其从终结列表中移除，并附加到freachable队列，队列中的每个引用都代表其Finalize方法已准备好的一个对象。

**注：**当垃圾回收器将对象的引用从终结列表移至freachable队列时，对象不在被认为是垃圾，不能回收它的内存，此时对象被**复活**。

**注：**可终结对象需要执行两次垃圾回收才能释放它们占用的内存，由于对象可能被提升至下一代，所以可能要求不止进行两次垃圾回收。

# 第22章 CLR寄宿和AppDomain

## 1.
